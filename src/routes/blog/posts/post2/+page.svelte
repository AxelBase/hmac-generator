<script lang="ts">
  import { base } from '$app/paths';
</script>

<svelte:head>
  <title>How HMAC-SHA256 Validation Works | AxelBase Blog</title>
  <meta name="description" content="A detailed explanation of how HMAC-SHA256 signature validation works and how systems verify message authenticity." />
  <meta property="og:title" content="How HMAC-SHA256 Validation Works | AxelBase Blog" />
  <meta property="og:description" content="A detailed explanation of how HMAC-SHA256 signature validation works and how systems verify message authenticity." />
  <meta property="og:url" content="{base}/blog/posts/post2" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary_large_image" />
</svelte:head>

<div class="container fade-in post-layout">
  <div class="breadcrumbs">
    <a href="{base}/blog">Blog</a>
    <span>/</span>
    <p>How HMAC-SHA256 Validation Works</p>
  </div>

  <article class="prose">
    <h1>How HMAC-SHA256 Validation Works</h1>

    <p class="post-meta">Published: November 2025</p>

    <p>
      Validation is the heart of the HMAC-SHA256 process. When one system sends a signed message to another, 
      the receiving system must confirm that the message came from a trusted source and has not been altered. 
      Understanding how validation works helps developers debug signature mismatch errors, build secure systems, 
      and avoid encoding-related pitfalls.
    </p>

    <h2>Step 1: Receive the Message and Signature</h2>
    <p>
      When a system receives a signed message, it usually arrives with two components:
    </p>
    <ul>
      <li>The <strong>payload</strong> (the message being authenticated)</li>
      <li>The <strong>HMAC-SHA256 signature</strong> generated by the sender</li>
    </ul>

    <h2>Step 2: Recreate the Signature</h2>
    <p>
      Using the same secret key as the sender, the recipient computes a new HMAC-SHA256 signature of the message. 
      If the systems agree on encoding and message formatting, both parties should arrive at the exact same hash.
    </p>

    <h2>Step 3: Compare the Two Signatures</h2>
    <p>
      A timing-safe comparison is used to check whether the provided signature and freshly computed one match. 
      If they do, the message is valid. If not, either the message was altered or the wrong encoding was used.
    </p>

    <h2>Common Causes of Signature Mismatches</h2>
    <ul>
      <li>Mismatched encoding (UTF-8 vs Base64 vs hex)</li>
      <li>Extra whitespace, newlines, or formatting changes</li>
      <li>Incorrectly normalized JSON objects</li>
      <li>Wrong hashing algorithm used by mistake</li>
    </ul>

    <h2>The Importance of Encoding</h2>
    <p>
      Many signature failures come from encoding differences rather than incorrect secret keys. 
      Systems must agree not only on the key and message but also on how bytes are interpreted. 
      Even a subtle change in character encoding can produce an entirely different HMAC.
    </p>

    <p class="italic-note">
      Validation ensures trust, integrity, and authenticity—three pillars of secure digital communication.
    </p>
  </article>
</div>

<style>
  .post-layout {
    max-width: 800px;
    padding-top: 2rem;
    padding-bottom: 4rem;
  }

  .breadcrumbs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    font-size: 0.9rem;
    color: var(--text-secondary);
  }
  .breadcrumbs a {
    color: var(--accent-secondary);
  }
  .breadcrumbs a:hover {
    text-decoration: underline;
  }
  .breadcrumbs p {
    margin: 0;
  }

  .prose {
    line-height: 1.8;
  }

  .prose .post-meta {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 2rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 1rem;
  }

  .prose h1, .prose h2 {
    color: var(--accent-secondary);
  }

  .prose h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .prose h2 {
    margin-top: 2.5rem;
    border-bottom: 1px solid var(--secondary-bg);
    padding-bottom: 0.5rem;
  }
  
  .prose p {
    color: var(--text-primary);
  }

  .prose ul {
    list-style-type: '→ ';
    padding-left: 1.5rem;
    color: var(--text-primary);
  }
  .prose ul li::marker {
    color: var(--accent-primary);
  }
  .prose ul li {
    padding-left: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .prose .italic-note {
    font-style: italic;
    color: var(--text-secondary);
    text-align: center;
    margin-top: 3rem;
  }
</style>
